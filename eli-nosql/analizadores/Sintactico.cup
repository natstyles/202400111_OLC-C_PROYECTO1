package analizadores;

import java_cup.runtime.Symbol;

parser code {:
    // Variables para conectar con la Interfaz Grafica
    private java.util.function.Consumer<String> log = null;
    private java.util.function.Consumer<String[]> errSink = null;

    // Indica si se detectó algún error durante el parseo
    public boolean hayErrores = false;

    public Sintactico(java_cup.runtime.Scanner s,
                      java.util.function.Consumer<String> log,
                      java.util.function.Consumer<String[]> errSink) {
        super(s);
        this.log = log;
        this.errSink = errSink;
    }

    //enviar mensajes a la consola del IDE
    private void emit(String msg) {
        if (log != null) log.accept(msg);
        else System.out.println(msg);
    }

    //enviar errores a la tabla
    private void pushErr(String tipo, String desc, Symbol sym) {
        if (errSink != null && sym != null) {
            errSink.accept(new String[]{ tipo, desc, String.valueOf(sym.left), String.valueOf(sym.right) });
        }
    }

    // Se ejecuta cuando CUP detecta un error pero intenta recuperarse
    @Override
    public void syntax_error(Symbol s) {
        this.hayErrores = true; //Levantamos la bandera de error

        String lexema = "";
        if (s.value != null) {
            lexema = s.value.toString();
        } else {
            //Intenta obtener el nombre del token si no tiene un valor en texto
            try { lexema = sym.terminalNames[s.sym]; }
            catch (Exception e) { lexema = "Token desconocido"; }
        }

        String mensaje;
        if (s.sym == sym.EOF) {
            mensaje = "Se alcanzó el final del archivo inesperadamente. Verifica que no falte cerrar una llave '}' o un punto y coma ';'.";
        } else {
            mensaje = "Sintaxis incorrecta cerca de '" + lexema + "'. Es posible que falte un punto y coma ';', una llave, o la estructura sea inválida.";
        }

        emit("Error Sintáctico: " + mensaje + " [Linea: " + s.left + ", Columna: " + s.right + "]");
        pushErr("Sintáctico", mensaje, s);
    }

    //cuando CUP ya no puede recuperarse del error
    @Override
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        this.hayErrores = true;
        String lexema = (s.value != null) ? s.value.toString() : "elemento";
        String mensaje = "Error Fatal irrecuperable cerca de '" + lexema + "'. No se pudo continuar el análisis.";

        emit("Error Fatal: " + mensaje + " [Linea: " + s.left + ", Columna: " + s.right + "]");
        pushErr("Sintáctico", mensaje, s);
    }
:};

/* Terminales */
terminal DATABASE, USE, TABLE, READ, FIELDS, FILTER, STORE, AT, EXPORT, ADD, UPDATE, SET, CLEAR;
terminal T_INT, T_STRING, T_FLOAT, T_BOOL, T_ARRAY, T_OBJECT, TRUE, FALSE, NULL;
terminal LLAVE_ABRE, LLAVE_CIERRA, PAR_ABRE, PAR_CIERRA, COR_ABRE, COR_CIERRA;
terminal DOS_PUNTOS, PUNTO_COMA, COMA, ASTERISCO;
terminal MAYOR_IGUAL, MENOR_IGUAL, IGUAL_IGUAL, DIFERENTE, MAYOR, MENOR;
terminal AND, OR, NOT;
terminal IGUAL;
terminal String ID, CADENA, ENTERO, DECIMAL;
terminal String ERROR;

/* no terminales */
non terminal program, stmts, stmt;
non terminal db_def, store_opt, use_def, table_def, col_list, col_decl, type_def;
non terminal read_stmt, field_decl, filter_decl, id_list, expr;
non terminal export_stmt, add_stmt, pair_list, pair_assign;
non terminal update_stmt, assign_list, assign_elem, clear_stmt;
non terminal value, array_def, val_list;

/* precedencia */
precedence left OR;
precedence left AND;
precedence left IGUAL_IGUAL, DIFERENTE, MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL;
precedence right NOT;

start with program;

%%

/* gramáticas */

program
  ::= stmts
  ;

stmts
  ::= stmts stmt
   |  /* empty */
  ;

stmt
  ::= db_def
   |  use_def
   |  table_def
   |  read_stmt
   |  export_stmt
   |  add_stmt
   |  update_stmt
   |  clear_stmt
   |  error PUNTO_COMA  {: emit("Error recuperado en punto y coma."); :}
   |  error LLAVE_CIERRA {: emit("Error recuperado en llave de cierre."); :}
  ;

/* DATABASE: database <id> { store at "ruta"; (Opcional) } */
db_def
  ::= DATABASE ID LLAVE_ABRE store_opt LLAVE_CIERRA
  ;

store_opt
  ::= STORE AT CADENA PUNTO_COMA
   |  /* vacio */
  ;

/* USE: use <id>; */
use_def
  ::= USE ID PUNTO_COMA
  ;

/* TABLE: table <id> { col: tipo; ... } */
table_def
  ::= TABLE ID LLAVE_ABRE col_list LLAVE_CIERRA
  ;

col_list
  ::= col_list col_decl
   |  col_decl
  ;

col_decl
  ::= ID DOS_PUNTOS type_def PUNTO_COMA
  ;

type_def
  ::= T_INT | T_STRING | T_FLOAT | T_BOOL
  ;

/* READ: read <id> { fields: ...; filter: ...; }; */
read_stmt
  ::= READ ID LLAVE_ABRE field_decl filter_decl LLAVE_CIERRA PUNTO_COMA
   |  READ ID LLAVE_ABRE field_decl LLAVE_CIERRA PUNTO_COMA
  ;

field_decl
  ::= FIELDS DOS_PUNTOS id_list PUNTO_COMA
   |  FIELDS DOS_PUNTOS id_list COMA
   |  FIELDS DOS_PUNTOS ASTERISCO PUNTO_COMA
   |  FIELDS DOS_PUNTOS ASTERISCO COMA
  ;

id_list
  ::= id_list COMA ID
   |  ID
  ;

filter_decl
  ::= FILTER DOS_PUNTOS expr PUNTO_COMA
   |  FILTER DOS_PUNTOS expr COMA
   |  FILTER DOS_PUNTOS expr
  ;

/* EXPORT: export "archivo.json"; */
export_stmt
  ::= EXPORT CADENA PUNTO_COMA
  ;

/* ADD: add <id> { campo: valor, ... }; */
add_stmt
  ::= ADD ID LLAVE_ABRE pair_list LLAVE_CIERRA PUNTO_COMA
  ;

pair_list
  ::= pair_list COMA pair_assign
   |  pair_assign
  ;

pair_assign
  ::= ID DOS_PUNTOS value
  ;

/* UPDATE */
update_stmt
  ::= UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA filter_decl LLAVE_CIERRA PUNTO_COMA
   |  UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA LLAVE_CIERRA PUNTO_COMA
  ;

assign_list
  ::= assign_list COMA assign_elem
   |  assign_elem
  ;

assign_elem
  ::= ID IGUAL value
  ;

/* CLEAR: clear <id>; */
clear_stmt
  ::= CLEAR ID PUNTO_COMA
  ;

/* Valores, Expresiones y Arreglos */
value
  ::= CADENA
   |  ENTERO
   |  DECIMAL
   |  TRUE
   |  FALSE
   |  NULL
   |  array_def
  ;

array_def
  ::= COR_ABRE val_list COR_CIERRA
   |  COR_ABRE COR_CIERRA
  ;

val_list
  ::= val_list COMA value
   |  value
  ;

expr
  ::= expr OR expr
   |  expr AND expr
   |  NOT expr
   |  PAR_ABRE expr PAR_CIERRA
   |  ID IGUAL_IGUAL value
   |  ID DIFERENTE value
   |  ID MAYOR value
   |  ID MENOR value
   |  ID MAYOR_IGUAL value
   |  ID MENOR_IGUAL value
  ;