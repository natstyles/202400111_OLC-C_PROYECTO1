package analizadores;

import java_cup.runtime.Symbol;
import ejecucion.*;
import java.util.LinkedList;

parser code {:
    // Variables para conectar con la Interfaz Grafica
    private java.util.function.Consumer<String> log = null;
    private java.util.function.Consumer<String[]> errSink = null;

    // BANDERA: Indica si se detectó algún error durante el parseo
    public boolean hayErrores = false;

    // -------------------------------------------------------------------------
    // CONSTRUCTOR PERSONALIZADO (3 Argumentos)
    // -------------------------------------------------------------------------
    public Sintactico(java_cup.runtime.Scanner s,
                      java.util.function.Consumer<String> log,
                      java.util.function.Consumer<String[]> errSink) {
        super(s);
        this.log = log;
        this.errSink = errSink;
    }

    private void emit(String msg) {
        if (log != null) log.accept(msg);
        else System.out.println(msg);
    }

    private void pushErr(String tipo, String desc, Symbol sym) {
        if (errSink != null && sym != null) {
            errSink.accept(new String[]{ tipo, desc, String.valueOf(sym.left), String.valueOf(sym.right) });
        }
    }

    // NUEVO MÉTODO: Inyecta errores a la tabla sin romper el parser
    public void reportar_error_manual(String mensaje, int linea, int columna) {
        this.hayErrores = true;
        emit("Error Sintáctico: " + mensaje + " [Linea: " + linea + ", Columna: " + columna + "]");
        if (errSink != null) {
            errSink.accept(new String[]{ "Sintáctico", mensaje, String.valueOf(linea), String.valueOf(columna) });
        }
    }

    // Se ejecuta cuando CUP detecta un error nativo
    @Override
    public void syntax_error(Symbol s) {
        this.hayErrores = true;
        String lexema = (s.value != null) ? s.value.toString() : "Token desconocido";
        String mensaje = (s.sym == sym.EOF)
            ? "Se alcanzó el final del archivo inesperadamente. Verifica que no falte cerrar una llave '}' o un punto y coma ';'."
            : "Sintaxis incorrecta cerca de '" + lexema + "'.";

        emit("Error Sintáctico: " + mensaje + " [Linea: " + s.left + ", Columna: " + s.right + "]");
        pushErr("Sintáctico", mensaje, s);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        this.hayErrores = true;
        String lexema = (s.value != null) ? s.value.toString() : "elemento";
        String mensaje = "Error Fatal irrecuperable cerca de '" + lexema + "'.";
        emit("Error Fatal: " + mensaje + " [Linea: " + s.left + ", Columna: " + s.right + "]");
        pushErr("Sintáctico", mensaje, s);
    }
:};

/* ====== TERMINALES ====== */
terminal DATABASE, USE, TABLE, READ, FIELDS, FILTER, STORE, AT, EXPORT, ADD, UPDATE, SET, CLEAR;
terminal T_INT, T_STRING, T_FLOAT, T_BOOL, T_ARRAY, T_OBJECT, TRUE, FALSE, NULL;
terminal LLAVE_ABRE, LLAVE_CIERRA, PAR_ABRE, PAR_CIERRA, COR_ABRE, COR_CIERRA;
terminal DOS_PUNTOS, PUNTO_COMA, COMA, ASTERISCO;
terminal MAYOR_IGUAL, MENOR_IGUAL, IGUAL_IGUAL, DIFERENTE, MAYOR, MENOR;
terminal AND, OR, NOT;
terminal IGUAL;
terminal String ID, CADENA, ENTERO, DECIMAL;
terminal String ERROR;

/* ====== NO TERMINALES ====== */
non terminal LinkedList<Instruccion> program, stmts;
non terminal Instruccion stmt, db_def, use_def, table_def;
non terminal Instruccion read_stmt, export_stmt, add_stmt, update_stmt, clear_stmt;
non terminal String store_opt;
non terminal java.util.LinkedList<ejecucion.Columna> col_list;
non terminal ejecucion.Columna col_decl;
non terminal String type_def;
non terminal java.util.LinkedList<ejecucion.Asignacion> pair_list;
non terminal ejecucion.Asignacion pair_assign;
non terminal ejecucion.Expresion value;
non terminal ejecucion.Expresion expr;
non terminal ejecucion.Expresion filter_decl;
non terminal java.util.LinkedList<ejecucion.Asignacion> assign_list;
non terminal ejecucion.Asignacion assign_elem;

/* AÚN NO TIPADOS (SE ACTUALIZARÁN DESPUÉS) */
non terminal field_decl, id_list;
non terminal array_def, val_list;

/* ====== PRECEDENCIAS ====== */
precedence left OR;
precedence left AND;
precedence left IGUAL_IGUAL, DIFERENTE, MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL;
precedence right NOT;

start with program;

%%

/* ================= GRAMATICA ================= */
program
  ::= stmts:s
      {:
         //devuelve la lista completa de instrucciones
         RESULT = s;
      :}
  ;

stmts
  ::= stmts:lista stmt:s
      {:
         //agregar la instrucción a la lista
         if (s != null) lista.add(s);
         RESULT = lista;
      :}
   |  /* empty */
      {:
         //crear la lista vacía
         RESULT = new LinkedList<>();
      :}
  ;

stmt
  ::= use_def:u       {: RESULT = u; :}
   |  db_def:d        {: RESULT = d; :}
   |  table_def:t     {: RESULT = t; :}
   |  read_stmt
   |  export_stmt
   |  add_stmt:a      {: RESULT = a; :}
   |  update_stmt:u   {: RESULT = u; :}
   |  clear_stmt
   |  error PUNTO_COMA    {: RESULT = null; :}
   |  error LLAVE_CIERRA  {: RESULT = null; :}
  ;

/* 1. DATABASE */
db_def
  ::= DATABASE ID:id LLAVE_ABRE store_opt:ruta LLAVE_CIERRA
      {:
         // Instanciamos el nodo CrearBD pasándole el ID y la ruta
         RESULT = new CrearBD(id, ruta);
      :}
   |  DATABASE ID LLAVE_ABRE error LLAVE_CIERRA
      {:
         RESULT = null;
      :}
  ;

store_opt
  ::= STORE AT CADENA:c PUNTO_COMA
      {:
         // Si el usuario especifica la ruta, la devolvemos
         RESULT = c;
      :}
   |  /* vacio */
      {:
         // Si la omite, el manual dice que usamos una por defecto
         RESULT = "ruta_por_defecto.json";
      :}
  ;

/* 2. USE */
use_def
  ::= USE ID:id PUNTO_COMA
      {:
         // ¡AQUÍ ESTÁ LA MAGIA! Instanciamos nuestro nodo del AST
         RESULT = new UseDB(id);
      :}
   |  USE error PUNTO_COMA
      {:
         // Si hubo error, devolvemos null para no meter basura al AST
         RESULT = null;
      :}
  ;

/* 3. TABLE */
table_def
  ::= TABLE ID:id LLAVE_ABRE col_list:cols LLAVE_CIERRA
      {:
         RESULT = new CrearTabla(id, cols);
      :}
   |  TABLE ID LLAVE_ABRE error LLAVE_CIERRA
      {:
         RESULT = null;
      :}
  ;

col_list
  ::= col_list:lista col_decl:col
      {:
         if(col != null) lista.add(col);
         RESULT = lista;
      :}
   |  col_decl:col
      {:
         java.util.LinkedList<ejecucion.Columna> lista = new java.util.LinkedList<>();
         if(col != null) lista.add(col);
         RESULT = lista;
      :}
  ;

col_decl
  ::= ID:id DOS_PUNTOS type_def:tipo PUNTO_COMA
      {:
         RESULT = new Columna(id, tipo);
      :}
  ;

type_def
  ::= T_INT     {: RESULT = "int"; :}
   |  T_STRING  {: RESULT = "string"; :}
   |  T_FLOAT   {: RESULT = "float"; :}
   |  T_BOOL    {: RESULT = "bool"; :}
   |  T_ARRAY   {: RESULT = "array"; :}
   |  T_OBJECT  {: RESULT = "object"; :}
  ;

/* 4. READ (SÍ lleva ';' al final de la llave) */
read_stmt
  ::= READ ID LLAVE_ABRE field_decl filter_decl LLAVE_CIERRA PUNTO_COMA
   |  READ ID LLAVE_ABRE field_decl LLAVE_CIERRA PUNTO_COMA

   /* Faltó ';' al final del bloque */
   |  READ ID LLAVE_ABRE field_decl filter_decl LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'read'", cleft, cright); :}
   |  READ ID LLAVE_ABRE field_decl LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'read'", cleft, cright); :}

   /* Modo Pánico: Error interno, y SI tiene el ';' final */
   |  READ ID LLAVE_ABRE error LLAVE_CIERRA PUNTO_COMA

   /* Modo Pánico: Error interno, Y TAMBIEN le falta el ';' final */
   |  READ ID LLAVE_ABRE error LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'read'", cleft, cright); :}
  ;

field_decl
  ::= FIELDS DOS_PUNTOS id_list PUNTO_COMA
   |  FIELDS DOS_PUNTOS ASTERISCO PUNTO_COMA
  ;

id_list
  ::= id_list COMA ID
   |  ID
  ;

filter_decl
  ::= FILTER DOS_PUNTOS expr:e PUNTO_COMA
      {: RESULT = e; :}
  ;

/* 5. EXPORT */
export_stmt
  ::= EXPORT CADENA PUNTO_COMA
   |  EXPORT error PUNTO_COMA
  ;

/* 6. ADD: add <id> { campo: valor, ... }; */
add_stmt
  ::= ADD ID:id LLAVE_ABRE pair_list:pares LLAVE_CIERRA PUNTO_COMA
      {:
         RESULT = new Insertar(id, pares);
      :}
   |  ADD ID LLAVE_ABRE error LLAVE_CIERRA PUNTO_COMA
      {: RESULT = null; :}
  ;

pair_list
  ::= pair_list:lista COMA pair_assign:par
      {:
         if(par != null) lista.add(par);
         RESULT = lista;
      :}
   |  pair_assign:par
      {:
         java.util.LinkedList<ejecucion.Asignacion> lista = new java.util.LinkedList<>();
         if(par != null) lista.add(par);
         RESULT = lista;
      :}
  ;

pair_assign
  ::= ID:id DOS_PUNTOS value:val
      {:
         RESULT = new Asignacion(id, val);
      :}
  ;

/* 7. UPDATE */
update_stmt
  ::= UPDATE ID:id LLAVE_ABRE SET DOS_PUNTOS assign_list:asigs PUNTO_COMA filter_decl:f LLAVE_CIERRA PUNTO_COMA
      {: RESULT = new Actualizar(id, asigs, f); :}

   |  UPDATE ID:id LLAVE_ABRE SET DOS_PUNTOS assign_list:asigs PUNTO_COMA LLAVE_CIERRA PUNTO_COMA
      {: RESULT = new Actualizar(id, asigs, null); :}

   /* ---- PANIC MODE (Devuelven null para no ensuciar el AST) ---- */
   |  UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA filter_decl LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'update'", cleft, cright); RESULT = null; :}
   |  UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'update'", cleft, cright); RESULT = null; :}
   |  UPDATE ID LLAVE_ABRE error LLAVE_CIERRA PUNTO_COMA
      {: RESULT = null; :}
   |  UPDATE ID LLAVE_ABRE error LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'update'", cleft, cright); RESULT = null; :}
  ;

assign_list
  ::= assign_list:lista COMA assign_elem:asig
      {:
         if(asig != null) lista.add(asig);
         RESULT = lista;
      :}
   |  assign_elem:asig
      {:
         java.util.LinkedList<ejecucion.Asignacion> lista = new java.util.LinkedList<>();
         if(asig != null) lista.add(asig);
         RESULT = lista;
      :}
  ;

assign_elem
  ::= ID:id IGUAL value:v
      {:
         RESULT = new Asignacion(id, v);
      :}
  ;

/* 8. CLEAR */
clear_stmt
  ::= CLEAR ID PUNTO_COMA
   |  CLEAR error PUNTO_COMA
  ;

/* Valores Literales (Conectados al nodo Literal.java) */
value
  ::= CADENA:c  {: RESULT = new Literal(c, "string"); :}
   |  ENTERO:e  {: RESULT = new Literal(Integer.parseInt(e), "int"); :}
   |  DECIMAL:d {: RESULT = new Literal(Double.parseDouble(d), "float"); :}
   |  TRUE      {: RESULT = new Literal(true, "bool"); :}
   |  FALSE     {: RESULT = new Literal(false, "bool"); :}
   |  NULL      {: RESULT = new Literal(null, "null"); :}
  ;

array_def
  ::= COR_ABRE val_list COR_CIERRA
   |  COR_ABRE COR_CIERRA
  ;

val_list
  ::= val_list COMA value
   |  value
  ;

/* Expresiones Lógicas y Relacionales */
expr
  ::= expr:i OR expr:d            {: RESULT = new Logica(i, "OR", d); :}
   |  expr:i AND expr:d           {: RESULT = new Logica(i, "AND", d); :}
   |  NOT expr:d                  {: RESULT = new Logica(null, "NOT", d); :}
   |  PAR_ABRE expr:e PAR_CIERRA  {: RESULT = e; :}

   |  ID:id IGUAL_IGUAL value:v   {: RESULT = new Condicion(id, "==", v); :}
   |  ID:id DIFERENTE value:v     {: RESULT = new Condicion(id, "!=", v); :}
   |  ID:id MAYOR value:v         {: RESULT = new Condicion(id, ">", v); :}
   |  ID:id MENOR value:v         {: RESULT = new Condicion(id, "<", v); :}
   |  ID:id MAYOR_IGUAL value:v   {: RESULT = new Condicion(id, ">=", v); :}
   |  ID:id MENOR_IGUAL value:v   {: RESULT = new Condicion(id, "<=", v); :}
  ;