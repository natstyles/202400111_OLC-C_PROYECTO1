package analizadores;

import java_cup.runtime.Symbol;

parser code {:
    // Variables para conectar con la Interfaz Grafica
    private java.util.function.Consumer<String> log = null;
    private java.util.function.Consumer<String[]> errSink = null;

    // BANDERA: Indica si se detectó algún error durante el parseo
    public boolean hayErrores = false;

    // -------------------------------------------------------------------------
    // CONSTRUCTOR PERSONALIZADO (3 Argumentos)
    // -------------------------------------------------------------------------
    public Sintactico(java_cup.runtime.Scanner s,
                      java.util.function.Consumer<String> log,
                      java.util.function.Consumer<String[]> errSink) {
        super(s);
        this.log = log;
        this.errSink = errSink;
    }

    private void emit(String msg) {
        if (log != null) log.accept(msg);
        else System.out.println(msg);
    }

    private void pushErr(String tipo, String desc, Symbol sym) {
        if (errSink != null && sym != null) {
            errSink.accept(new String[]{ tipo, desc, String.valueOf(sym.left), String.valueOf(sym.right) });
        }
    }

    // NUEVO MÉTODO: Inyecta errores a la tabla sin romper el parser
    public void reportar_error_manual(String mensaje, int linea, int columna) {
        this.hayErrores = true;
        emit("Error Sintáctico: " + mensaje + " [Linea: " + linea + ", Columna: " + columna + "]");
        if (errSink != null) {
            errSink.accept(new String[]{ "Sintáctico", mensaje, String.valueOf(linea), String.valueOf(columna) });
        }
    }

    // Se ejecuta cuando CUP detecta un error nativo
    @Override
    public void syntax_error(Symbol s) {
        this.hayErrores = true;
        String lexema = (s.value != null) ? s.value.toString() : "Token desconocido";
        String mensaje = (s.sym == sym.EOF)
            ? "Se alcanzó el final del archivo inesperadamente. Verifica que no falte cerrar una llave '}' o un punto y coma ';'."
            : "Sintaxis incorrecta cerca de '" + lexema + "'.";

        emit("Error Sintáctico: " + mensaje + " [Linea: " + s.left + ", Columna: " + s.right + "]");
        pushErr("Sintáctico", mensaje, s);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        this.hayErrores = true;
        String lexema = (s.value != null) ? s.value.toString() : "elemento";
        String mensaje = "Error Fatal irrecuperable cerca de '" + lexema + "'.";
        emit("Error Fatal: " + mensaje + " [Linea: " + s.left + ", Columna: " + s.right + "]");
        pushErr("Sintáctico", mensaje, s);
    }
:};

/* ====== TERMINALES ====== */
terminal DATABASE, USE, TABLE, READ, FIELDS, FILTER, STORE, AT, EXPORT, ADD, UPDATE, SET, CLEAR;
terminal T_INT, T_STRING, T_FLOAT, T_BOOL, T_ARRAY, T_OBJECT, TRUE, FALSE, NULL;
terminal LLAVE_ABRE, LLAVE_CIERRA, PAR_ABRE, PAR_CIERRA, COR_ABRE, COR_CIERRA;
terminal DOS_PUNTOS, PUNTO_COMA, COMA, ASTERISCO;
terminal MAYOR_IGUAL, MENOR_IGUAL, IGUAL_IGUAL, DIFERENTE, MAYOR, MENOR;
terminal AND, OR, NOT;
terminal IGUAL;
terminal String ID, CADENA, ENTERO, DECIMAL;
terminal String ERROR;

/* ====== NO TERMINALES ====== */
non terminal program, stmts, stmt;
non terminal db_def, store_opt, use_def, table_def, col_list, col_decl, type_def;
non terminal read_stmt, field_decl, filter_decl, id_list, expr;
non terminal export_stmt, add_stmt, pair_list, pair_assign;
non terminal update_stmt, assign_list, assign_elem, clear_stmt;
non terminal value, array_def, val_list;

/* ====== PRECEDENCIAS ====== */
precedence left OR;
precedence left AND;
precedence left IGUAL_IGUAL, DIFERENTE, MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL;
precedence right NOT;

start with program;

%%

/* ================= GRAMATICA ================= */

program
  ::= stmts
  ;

stmts
  ::= stmts stmt
   |  /* vacio */
  ;

stmt
  ::= db_def
   |  use_def
   |  table_def
   |  read_stmt
   |  export_stmt
   |  add_stmt
   |  update_stmt
   |  clear_stmt
   |  error PUNTO_COMA
   |  error LLAVE_CIERRA
  ;

/* 1. DATABASE (No lleva ';' al final de la llave) */
db_def
  ::= DATABASE ID LLAVE_ABRE store_opt LLAVE_CIERRA
   |  DATABASE ID LLAVE_ABRE error LLAVE_CIERRA
  ;

store_opt
  ::= STORE AT CADENA PUNTO_COMA
   |  /* vacio */
  ;

/* 2. USE */
use_def
  ::= USE ID PUNTO_COMA
   |  USE error PUNTO_COMA
  ;

/* 3. TABLE (No lleva ';' al final de la llave) */
table_def
  ::= TABLE ID LLAVE_ABRE col_list LLAVE_CIERRA
   |  TABLE ID LLAVE_ABRE error LLAVE_CIERRA
  ;

col_list
  ::= col_list col_decl
   |  col_decl
  ;

col_decl
  ::= ID DOS_PUNTOS type_def PUNTO_COMA
  ;

type_def
  ::= T_INT | T_STRING | T_FLOAT | T_BOOL | T_ARRAY | T_OBJECT
  ;

/* 4. READ (SÍ lleva ';' al final de la llave) */
read_stmt
  ::= READ ID LLAVE_ABRE field_decl filter_decl LLAVE_CIERRA PUNTO_COMA
   |  READ ID LLAVE_ABRE field_decl LLAVE_CIERRA PUNTO_COMA

   /* Faltó ';' al final del bloque */
   |  READ ID LLAVE_ABRE field_decl filter_decl LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'read'", cleft, cright); :}
   |  READ ID LLAVE_ABRE field_decl LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'read'", cleft, cright); :}

   /* Modo Pánico: Error interno, y SI tiene el ';' final */
   |  READ ID LLAVE_ABRE error LLAVE_CIERRA PUNTO_COMA

   /* Modo Pánico: Error interno, Y TAMBIEN le falta el ';' final */
   |  READ ID LLAVE_ABRE error LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'read'", cleft, cright); :}
  ;

field_decl
  ::= FIELDS DOS_PUNTOS id_list PUNTO_COMA
   |  FIELDS DOS_PUNTOS ASTERISCO PUNTO_COMA
  ;

id_list
  ::= id_list COMA ID
   |  ID
  ;

filter_decl
  ::= FILTER DOS_PUNTOS expr PUNTO_COMA
  ;

/* 5. EXPORT */
export_stmt
  ::= EXPORT CADENA PUNTO_COMA
   |  EXPORT error PUNTO_COMA
  ;

/* 6. ADD (SÍ lleva ';' al final de la llave) */
add_stmt
  ::= ADD ID LLAVE_ABRE pair_list LLAVE_CIERRA PUNTO_COMA

   /* Faltó ';' al final del bloque */
   |  ADD ID LLAVE_ABRE pair_list LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'add'", cleft, cright); :}

   /* Modo Pánico interno */
   |  ADD ID LLAVE_ABRE error LLAVE_CIERRA PUNTO_COMA
   |  ADD ID LLAVE_ABRE error LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'add'", cleft, cright); :}
  ;

pair_list
  ::= pair_list COMA pair_assign
   |  pair_assign
  ;

pair_assign
  ::= ID DOS_PUNTOS value
  ;

/* 7. UPDATE (SÍ lleva ';' al final de la llave) */
update_stmt
  ::= UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA filter_decl LLAVE_CIERRA PUNTO_COMA
   |  UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA LLAVE_CIERRA PUNTO_COMA

   /* Faltó ';' al final del bloque */
   |  UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA filter_decl LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'update'", cleft, cright); :}
   |  UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'update'", cleft, cright); :}

   /* Modo Pánico interno */
   |  UPDATE ID LLAVE_ABRE error LLAVE_CIERRA PUNTO_COMA
   |  UPDATE ID LLAVE_ABRE error LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'update'", cleft, cright); :}
  ;

assign_list
  ::= assign_list COMA assign_elem
   |  assign_elem
  ;

assign_elem
  ::= ID IGUAL value
  ;

/* 8. CLEAR */
clear_stmt
  ::= CLEAR ID PUNTO_COMA
   |  CLEAR error PUNTO_COMA
  ;

/* Valores y Arreglos */
value
  ::= CADENA
   |  ENTERO
   |  DECIMAL
   |  TRUE
   |  FALSE
   |  NULL
   |  array_def
  ;

array_def
  ::= COR_ABRE val_list COR_CIERRA
   |  COR_ABRE COR_CIERRA
  ;

val_list
  ::= val_list COMA value
   |  value
  ;

/* Expresiones */
expr
  ::= expr OR expr
   |  expr AND expr
   |  NOT expr
   |  PAR_ABRE expr PAR_CIERRA
   |  ID IGUAL_IGUAL value
   |  ID DIFERENTE value
   |  ID MAYOR value
   |  ID MENOR value
   |  ID MAYOR_IGUAL value
   |  ID MENOR_IGUAL value
  ;