package analizadores;

import java_cup.runtime.Symbol;

parser code {:
    // Variables para conectar con la Interfaz Grafica
    private java.util.function.Consumer<String> log = null;
    private java.util.function.Consumer<String[]> errSink = null;

    // -------------------------------------------------------------------------
    // CONSTRUCTOR PERSONALIZADO (3 Argumentos)
    // -------------------------------------------------------------------------
    public Sintactico(java_cup.runtime.Scanner s,
                      java.util.function.Consumer<String> log,
                      java.util.function.Consumer<String[]> errSink) {
        super(s);
        this.log = log;
        this.errSink = errSink;
    }

    // Metodo auxiliar para enviar mensajes a la consola del IDE
    private void emit(String msg) {
        if (log != null) log.accept(msg);
        else System.out.println(msg);
    }

    // Metodo auxiliar para enviar errores a la tabla de errores del IDE
    private void pushErr(String tipo, String desc, Object info) {
        if (errSink == null) return;
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol sym = (java_cup.runtime.Symbol) info;
            errSink.accept(new String[]{ tipo, desc, ""+sym.left, ""+sym.right });
        } else {
            errSink.accept(new String[]{tipo, desc, "-", "-"});
        }
    }

    // Metodo oficial de CUP para reportar errores
    public void report_error(String message, Object info) {
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
            emit("Error Sintactico: " + message + " [Linea: " + s.left + ", Columna: " + s.right + "]");
            pushErr("Sintactico", message, info);
        } else {
            emit("Error Sintactico: " + message);
            pushErr("Sintactico", message, info);
        }
    }

    // Metodo para errores fatales
    public void report_fatal_error(String message, Object info) {
        report_error("Error Fatal: " + message, info);
    }
:};

/* ====== TERMINALES ====== */
terminal DATABASE, USE, TABLE, READ, FIELDS, FILTER, STORE, AT, EXPORT, ADD, UPDATE, SET, CLEAR;
terminal T_INT, T_STRING, T_FLOAT, T_BOOL, T_ARRAY, T_OBJECT, TRUE, FALSE, NULL;
terminal LLAVE_ABRE, LLAVE_CIERRA, PAR_ABRE, PAR_CIERRA, COR_ABRE, COR_CIERRA;
terminal DOS_PUNTOS, PUNTO_COMA, COMA, ASTERISCO;
terminal MAYOR_IGUAL, MENOR_IGUAL, IGUAL_IGUAL, DIFERENTE, MAYOR, MENOR;
terminal AND, OR, NOT;
terminal IGUAL;
terminal String ID, CADENA, ENTERO, DECIMAL;
terminal String ERROR;

/* ====== NO TERMINALES ====== */
non terminal program, stmts, stmt;
non terminal db_def, store_opt, use_def, table_def, col_list, col_decl, type_def;
non terminal read_stmt, field_decl, filter_decl, id_list, expr;
non terminal export_stmt, add_stmt, pair_list, pair_assign;
non terminal update_stmt, assign_list, assign_elem, clear_stmt;
non terminal value, array_def, val_list;
non terminal sep, sep_opt;

/* ====== PRECEDENCIAS (De menor a mayor) ====== */
precedence left OR;
precedence left AND;
precedence left IGUAL_IGUAL, DIFERENTE, MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL;
precedence right NOT;

start with program;

%%

/* ================= GRAMATICA ================= */

program
  ::= stmts
  ;

stmts
  ::= stmts stmt
   |  /* vacio */
  ;

stmt
  ::= db_def
   |  use_def
   |  table_def
   |  read_stmt
   |  export_stmt
   |  add_stmt
   |  update_stmt
   |  clear_stmt
   |  error PUNTO_COMA  {: emit("Error recuperado en punto y coma."); :}
   |  error LLAVE_CIERRA {: emit("Error recuperado en llave de cierre."); :}
  ;

/* 1. DATABASE: database <id> { store at "ruta"; (Opcional) } */
db_def
  ::= DATABASE ID LLAVE_ABRE store_opt LLAVE_CIERRA
  ;

store_opt
  ::= STORE AT CADENA PUNTO_COMA
   |  /* vacio */
  ;

/* 2. USE: use <id>; */
use_def
  ::= USE ID PUNTO_COMA
  ;

/* 3. TABLE: table <id> { col: tipo; ... } */
table_def
  ::= TABLE ID LLAVE_ABRE col_list LLAVE_CIERRA
  ;

col_list
  ::= col_list col_decl
   |  col_decl
  ;

col_decl
  ::= ID DOS_PUNTOS type_def PUNTO_COMA
  ;

type_def
  ::= T_INT | T_STRING | T_FLOAT | T_BOOL
  ;

/* 4. READ: read <id> { fields: ...; filter: ...; }; */
read_stmt
  ::= READ ID LLAVE_ABRE field_decl filter_decl LLAVE_CIERRA
   |  READ ID LLAVE_ABRE field_decl LLAVE_CIERRA
  ;

field_decl
  ::= FIELDS DOS_PUNTOS id_list PUNTO_COMA
   |  FIELDS DOS_PUNTOS id_list COMA
   |  FIELDS DOS_PUNTOS ASTERISCO PUNTO_COMA
   |  FIELDS DOS_PUNTOS ASTERISCO COMA
  ;

id_list
  ::= id_list COMA ID
   |  ID
  ;

filter_decl
  ::= FILTER DOS_PUNTOS expr PUNTO_COMA
   |  FILTER DOS_PUNTOS expr COMA
   |  FILTER DOS_PUNTOS expr
  ;

/* Separadores flexibles para soportar los ejemplos del manual */
sep
  ::= PUNTO_COMA | COMA
  ;

sep_opt
  ::= PUNTO_COMA | COMA | /* vacio */
  ;

/* 5. EXPORT: export "archivo.json"; */
export_stmt
  ::= EXPORT CADENA PUNTO_COMA
  ;

/* 6. ADD: add <id> { campo: valor, ... }; */
add_stmt
  ::= ADD ID LLAVE_ABRE pair_list LLAVE_CIERRA PUNTO_COMA
  ;

pair_list
  ::= pair_list COMA pair_assign
   |  pair_assign
  ;

pair_assign
  ::= ID DOS_PUNTOS value
  ;

/* 7. UPDATE: update <id> { set: ...; filter: ...; }; */
update_stmt
  ::= UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list sep filter_decl LLAVE_CIERRA PUNTO_COMA
   |  UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list sep_opt LLAVE_CIERRA PUNTO_COMA
  ;

assign_list
  ::= assign_list COMA assign_elem
   |  assign_elem
  ;

assign_elem
  ::= ID IGUAL value
  ;

/* 8. CLEAR: clear <id>; */
clear_stmt
  ::= CLEAR ID PUNTO_COMA
  ;

/* Valores, Expresiones y Arreglos */
value
  ::= CADENA
   |  ENTERO
   |  DECIMAL
   |  TRUE
   |  FALSE
   |  NULL
   |  array_def
  ;

array_def
  ::= COR_ABRE val_list COR_CIERRA
   |  COR_ABRE COR_CIERRA
  ;

val_list
  ::= val_list COMA value
   |  value
  ;

expr
  ::= expr OR expr
   |  expr AND expr
   |  NOT expr
   |  PAR_ABRE expr PAR_CIERRA
   |  ID IGUAL_IGUAL value
   |  ID DIFERENTE value
   |  ID MAYOR value
   |  ID MENOR value
   |  ID MAYOR_IGUAL value
   |  ID MENOR_IGUAL value
  ;