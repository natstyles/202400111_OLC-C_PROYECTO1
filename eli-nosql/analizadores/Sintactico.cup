package analizadores;

import java_cup.runtime.Symbol;
import ejecucion.*;
import java.util.LinkedList;

parser code {:
    // Variables para conectar con la Interfaz Grafica
    private java.util.function.Consumer<String> log = null;
    private java.util.function.Consumer<String[]> errSink = null;

    // BANDERA: Indica si se detectó algún error durante el parseo
    public boolean hayErrores = false;

    // -------------------------------------------------------------------------
    // CONSTRUCTOR PERSONALIZADO (3 Argumentos)
    // -------------------------------------------------------------------------
    public Sintactico(java_cup.runtime.Scanner s,
                      java.util.function.Consumer<String> log,
                      java.util.function.Consumer<String[]> errSink) {
        super(s);
        this.log = log;
        this.errSink = errSink;
    }

    private void emit(String msg) {
        if (log != null) log.accept(msg);
        else System.out.println(msg);
    }

    private void pushErr(String tipo, String desc, Symbol sym) {
        if (errSink != null && sym != null) {
            errSink.accept(new String[]{ tipo, desc, String.valueOf(sym.left), String.valueOf(sym.right) });
        }
    }

    // NUEVO MÉTODO: Inyecta errores a la tabla sin romper el parser
    public void reportar_error_manual(String mensaje, int linea, int columna) {
        this.hayErrores = true;
        emit("Error Sintáctico: " + mensaje + " [Linea: " + linea + ", Columna: " + columna + "]");
        if (errSink != null) {
            errSink.accept(new String[]{ "Sintáctico", mensaje, String.valueOf(linea), String.valueOf(columna) });
        }
    }

    // Se ejecuta cuando CUP detecta un error nativo
    @Override
    public void syntax_error(Symbol s) {
        this.hayErrores = true;
        String lexema = (s.value != null) ? s.value.toString() : "Token desconocido";
        String mensaje = (s.sym == sym.EOF)
            ? "Se alcanzó el final del archivo inesperadamente. Verifica que no falte cerrar una llave '}' o un punto y coma ';'."
            : "Sintaxis incorrecta cerca de '" + lexema + "'.";

        emit("Error Sintáctico: " + mensaje + " [Linea: " + s.left + ", Columna: " + s.right + "]");
        pushErr("Sintáctico", mensaje, s);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        this.hayErrores = true;
        String lexema = (s.value != null) ? s.value.toString() : "elemento";
        String mensaje = "Error Fatal irrecuperable cerca de '" + lexema + "'.";
        emit("Error Fatal: " + mensaje + " [Linea: " + s.left + ", Columna: " + s.right + "]");
        pushErr("Sintáctico", mensaje, s);
    }
:};

/* ====== TERMINALES ====== */
terminal DATABASE, USE, TABLE, READ, FIELDS, FILTER, STORE, AT, EXPORT, ADD, UPDATE, SET, CLEAR;
terminal T_INT, T_STRING, T_FLOAT, T_BOOL, T_ARRAY, T_OBJECT, TRUE, FALSE, NULL;
terminal LLAVE_ABRE, LLAVE_CIERRA, PAR_ABRE, PAR_CIERRA, COR_ABRE, COR_CIERRA;
terminal DOS_PUNTOS, PUNTO_COMA, COMA, ASTERISCO;
terminal MAYOR_IGUAL, MENOR_IGUAL, IGUAL_IGUAL, DIFERENTE, MAYOR, MENOR;
terminal AND, OR, NOT;
terminal IGUAL;
terminal String ID, CADENA, ENTERO, DECIMAL;
terminal String ERROR;

/* ====== NO TERMINALES ====== */
non terminal LinkedList<Instruccion> program, stmts;
non terminal Instruccion stmt, db_def, use_def, table_def;
non terminal Instruccion read_stmt, export_stmt, add_stmt, update_stmt, clear_stmt;
non terminal String store_opt;

non terminal col_list, col_decl, type_def;
non terminal field_decl, filter_decl, id_list, expr;
non terminal pair_list, pair_assign;
non terminal assign_list, assign_elem;
non terminal value, array_def, val_list;

/* ====== PRECEDENCIAS ====== */
precedence left OR;
precedence left AND;
precedence left IGUAL_IGUAL, DIFERENTE, MAYOR, MENOR, MAYOR_IGUAL, MENOR_IGUAL;
precedence right NOT;

start with program;

%%

/* ================= GRAMATICA ================= */
program
  ::= stmts:s
      {:
         //devuelve la lista completa de instrucciones
         RESULT = s;
      :}
  ;

stmts
  ::= stmts:lista stmt:s
      {:
         //agregar la instrucción a la lista
         if (s != null) lista.add(s);
         RESULT = lista;
      :}
   |  /* empty */
      {:
         //crear la lista vacía
         RESULT = new LinkedList<>();
      :}
  ;

stmt
  ::= use_def:u       {: RESULT = u; :}
   |  db_def:d        {: RESULT = d; :}
   |  table_def
   |  read_stmt
   |  export_stmt
   |  add_stmt
   |  update_stmt
   |  clear_stmt
   |  error PUNTO_COMA    {: RESULT = null; :}
   |  error LLAVE_CIERRA  {: RESULT = null; :}
  ;

/* 1. DATABASE */
db_def
  ::= DATABASE ID:id LLAVE_ABRE store_opt:ruta LLAVE_CIERRA
      {:
         // Instanciamos el nodo CrearBD pasándole el ID y la ruta
         RESULT = new CrearBD(id, ruta);
      :}
   |  DATABASE ID LLAVE_ABRE error LLAVE_CIERRA
      {:
         RESULT = null;
      :}
  ;

store_opt
  ::= STORE AT CADENA:c PUNTO_COMA
      {:
         // Si el usuario especifica la ruta, la devolvemos
         RESULT = c;
      :}
   |  /* vacio */
      {:
         // Si la omite, el manual dice que usamos una por defecto
         RESULT = "ruta_por_defecto.json";
      :}
  ;

/* 2. USE */
use_def
  ::= USE ID:id PUNTO_COMA
      {:
         // ¡AQUÍ ESTÁ LA MAGIA! Instanciamos nuestro nodo del AST
         RESULT = new UseDB(id);
      :}
   |  USE error PUNTO_COMA
      {:
         // Si hubo error, devolvemos null para no meter basura al AST
         RESULT = null;
      :}
  ;

/* 3. TABLE (No lleva ';' al final de la llave) */
table_def
  ::= TABLE ID LLAVE_ABRE col_list LLAVE_CIERRA
   |  TABLE ID LLAVE_ABRE error LLAVE_CIERRA
  ;

col_list
  ::= col_list col_decl
   |  col_decl
  ;

col_decl
  ::= ID DOS_PUNTOS type_def PUNTO_COMA
  ;

type_def
  ::= T_INT | T_STRING | T_FLOAT | T_BOOL | T_ARRAY | T_OBJECT
  ;

/* 4. READ (SÍ lleva ';' al final de la llave) */
read_stmt
  ::= READ ID LLAVE_ABRE field_decl filter_decl LLAVE_CIERRA PUNTO_COMA
   |  READ ID LLAVE_ABRE field_decl LLAVE_CIERRA PUNTO_COMA

   /* Faltó ';' al final del bloque */
   |  READ ID LLAVE_ABRE field_decl filter_decl LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'read'", cleft, cright); :}
   |  READ ID LLAVE_ABRE field_decl LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'read'", cleft, cright); :}

   /* Modo Pánico: Error interno, y SI tiene el ';' final */
   |  READ ID LLAVE_ABRE error LLAVE_CIERRA PUNTO_COMA

   /* Modo Pánico: Error interno, Y TAMBIEN le falta el ';' final */
   |  READ ID LLAVE_ABRE error LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'read'", cleft, cright); :}
  ;

field_decl
  ::= FIELDS DOS_PUNTOS id_list PUNTO_COMA
   |  FIELDS DOS_PUNTOS ASTERISCO PUNTO_COMA
  ;

id_list
  ::= id_list COMA ID
   |  ID
  ;

filter_decl
  ::= FILTER DOS_PUNTOS expr PUNTO_COMA
  ;

/* 5. EXPORT */
export_stmt
  ::= EXPORT CADENA PUNTO_COMA
   |  EXPORT error PUNTO_COMA
  ;

/* 6. ADD (SÍ lleva ';' al final de la llave) */
add_stmt
  ::= ADD ID LLAVE_ABRE pair_list LLAVE_CIERRA PUNTO_COMA

   /* Faltó ';' al final del bloque */
   |  ADD ID LLAVE_ABRE pair_list LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'add'", cleft, cright); :}

   /* Modo Pánico interno */
   |  ADD ID LLAVE_ABRE error LLAVE_CIERRA PUNTO_COMA
   |  ADD ID LLAVE_ABRE error LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'add'", cleft, cright); :}
  ;

pair_list
  ::= pair_list COMA pair_assign
   |  pair_assign
  ;

pair_assign
  ::= ID DOS_PUNTOS value
  ;

/* 7. UPDATE (SÍ lleva ';' al final de la llave) */
update_stmt
  ::= UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA filter_decl LLAVE_CIERRA PUNTO_COMA
   |  UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA LLAVE_CIERRA PUNTO_COMA

   /* Faltó ';' al final del bloque */
   |  UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA filter_decl LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'update'", cleft, cright); :}
   |  UPDATE ID LLAVE_ABRE SET DOS_PUNTOS assign_list PUNTO_COMA LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'update'", cleft, cright); :}

   /* Modo Pánico interno */
   |  UPDATE ID LLAVE_ABRE error LLAVE_CIERRA PUNTO_COMA
   |  UPDATE ID LLAVE_ABRE error LLAVE_CIERRA:c
      {: parser.reportar_error_manual("Falta ';' al final de la instrucción 'update'", cleft, cright); :}
  ;

assign_list
  ::= assign_list COMA assign_elem
   |  assign_elem
  ;

assign_elem
  ::= ID IGUAL value
  ;

/* 8. CLEAR */
clear_stmt
  ::= CLEAR ID PUNTO_COMA
   |  CLEAR error PUNTO_COMA
  ;

/* Valores y Arreglos */
value
  ::= CADENA
   |  ENTERO
   |  DECIMAL
   |  TRUE
   |  FALSE
   |  NULL
   |  array_def
  ;

array_def
  ::= COR_ABRE val_list COR_CIERRA
   |  COR_ABRE COR_CIERRA
  ;

val_list
  ::= val_list COMA value
   |  value
  ;

/* Expresiones */
expr
  ::= expr OR expr
   |  expr AND expr
   |  NOT expr
   |  PAR_ABRE expr PAR_CIERRA
   |  ID IGUAL_IGUAL value
   |  ID DIFERENTE value
   |  ID MAYOR value
   |  ID MENOR value
   |  ID MAYOR_IGUAL value
   |  ID MENOR_IGUAL value
  ;